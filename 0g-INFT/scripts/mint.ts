import { ethers } from 'hardhat';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Phase 4 - Mint INFT
 * 
 * This script mints an INFT token bound to the encrypted storage reference
 * created in Phase 1, using the contracts deployed in Phase 3.
 * 
 * The script:
 * 1. Loads deployment data (contract addresses)
 * 2. Loads Phase 1 storage outputs (encryptedURI, metadataHash)
 * 3. Mints a new INFT token with the encrypted metadata reference
 * 4. Updates deployment tracking with minted token info
 * 5. Verifies the token was minted correctly
 */

interface DeploymentData {
  oracle: any;
  dataVerifier: any;
  inft: any;
}

interface StorageData {
  encryptedURI: string;
  storageRootHash: string;
  transactionHash: any;
  metadataHash: string;
  key: string;
  iv: string;
  tag: string;
  timestamp: string;
}

interface MintParams {
  tokenId?: number;  // Optional - will be auto-generated by contract
  to: string;        // Required - recipient address
  encryptedURI: string;  // Required - URI from Phase 1 storage
  metadataHash: string;  // Required - hash from Phase 1 storage
}

/**
 * Load deployment data from galileo.json
 */
function loadDeploymentData(): DeploymentData {
  const deploymentPath = path.join(__dirname, '..', 'deployments', 'galileo.json');
  
  if (!fs.existsSync(deploymentPath)) {
    throw new Error(`Deployment file not found: ${deploymentPath}`);
  }
  
  const deploymentData = JSON.parse(fs.readFileSync(deploymentPath, 'utf8'));
  
  // Validate required contracts are deployed
  if (!deploymentData.inft?.address) {
    throw new Error('INFT contract address not found in deployment data');
  }
  
  console.log('üìã Loaded deployment data:');
  console.log('  - INFT Contract:', deploymentData.inft.address);
  console.log('  - DataVerifier:', deploymentData.dataVerifier?.address || 'N/A');
  console.log('  - Oracle:', deploymentData.oracle?.address || 'N/A');
  
  return deploymentData;
}

/**
 * Load storage data from Phase 1 outputs
 */
function loadStorageData(): StorageData {
  const storagePath = path.join(__dirname, '..', 'storage', 'dev-keys.json');
  
  if (!fs.existsSync(storagePath)) {
    throw new Error(`Storage data file not found: ${storagePath}. Please run Phase 1 storage encryption first.`);
  }
  
  const storageData = JSON.parse(fs.readFileSync(storagePath, 'utf8'));
  
  // Validate required storage outputs
  if (!storageData.encryptedURI || !storageData.metadataHash) {
    throw new Error('Invalid storage data: missing encryptedURI or metadataHash');
  }
  
  console.log('üíæ Loaded Phase 1 storage data:');
  console.log('  - Encrypted URI:', storageData.encryptedURI);
  console.log('  - Metadata Hash:', storageData.metadataHash);
  console.log('  - Storage Root Hash:', storageData.storageRootHash);
  
  return storageData;
}

/**
 * Validate mint parameters
 */
function validateMintParams(params: MintParams): void {
  if (!params.to || !ethers.isAddress(params.to)) {
    throw new Error(`Invalid recipient address: ${params.to}`);
  }
  
  if (!params.encryptedURI || params.encryptedURI.trim() === '') {
    throw new Error('Encrypted URI cannot be empty');
  }
  
  if (!params.metadataHash || params.metadataHash === '0x' || params.metadataHash.length !== 66) {
    throw new Error(`Invalid metadata hash: ${params.metadataHash}`);
  }
  
  console.log('‚úÖ Mint parameters validated');
}

/**
 * Get network information
 */
async function getNetworkInfo() {
  const [signer] = await ethers.getSigners();
  const provider = signer.provider;
  const network = await provider.getNetwork();
  const balance = await provider.getBalance(signer.address);
  
  console.log('üåê Network Information:');
  console.log('  - Chain ID:', network.chainId.toString());
  console.log('  - Network Name:', network.name);
  console.log('  - Signer Address:', signer.address);
  console.log('  - Balance:', ethers.formatEther(balance), 'OG');
  
  // Verify we're on 0G Galileo testnet
  if (network.chainId !== 16601n) {
    throw new Error(`Expected 0G Galileo testnet (Chain ID: 16601), but connected to Chain ID: ${network.chainId}`);
  }
  
  // Check minimum balance for transaction
  const minBalance = ethers.parseEther('0.01'); // 0.01 OG minimum
  if (balance < minBalance) {
    throw new Error(`Insufficient balance. Required: ${ethers.formatEther(minBalance)} OG, Available: ${ethers.formatEther(balance)} OG`);
  }
  
  return { signer, provider, network };
}

/**
 * Mint the INFT token
 */
async function mintINFT(
  deploymentData: DeploymentData,
  mintParams: MintParams,
  signer: any
): Promise<{tokenId: number, txHash: string, gasUsed: string}> {
  
  console.log('üè≠ Connecting to INFT contract...');
  
  // Get the INFT contract instance
  const INFT = await ethers.getContractFactory('INFT');
  const inftContract = INFT.attach(deploymentData.inft.address).connect(signer);
  
  // Verify contract is accessible
  const contractName = await inftContract.name();
  const contractSymbol = await inftContract.symbol();
  console.log(`üìù Contract Info: ${contractName} (${contractSymbol})`);
  
  // Get current token ID counter (this will be the ID of our new token)
  const currentTokenId = await inftContract.getCurrentTokenId();
  const expectedTokenId = currentTokenId;
  
  console.log('üéØ Minting INFT with parameters:');
  console.log('  - Recipient:', mintParams.to);
  console.log('  - Expected Token ID:', expectedTokenId.toString());
  console.log('  - Encrypted URI:', mintParams.encryptedURI);
  console.log('  - Metadata Hash:', mintParams.metadataHash);
  
  // Execute the mint transaction
  console.log('üì§ Submitting mint transaction...');
  const tx = await inftContract.mint(
    mintParams.to,
    mintParams.encryptedURI,
    mintParams.metadataHash
  );
  
  console.log('‚è≥ Transaction submitted:', tx.hash);
  console.log('‚è≥ Waiting for confirmation...');
  
  // Wait for transaction to be mined
  const receipt = await tx.wait();
  
  if (receipt.status !== 1) {
    throw new Error(`Transaction failed with status: ${receipt.status}`);
  }
  
  // Extract Transfer event to get the actual token ID
  const transferEvent = receipt.logs.find((log: any) => {
    try {
      const parsed = inftContract.interface.parseLog(log);
      return parsed.name === 'Transfer';
    } catch {
      return false;
    }
  });
  
  let actualTokenId = expectedTokenId;
  if (transferEvent) {
    const parsed = inftContract.interface.parseLog(transferEvent);
    actualTokenId = parsed.args.tokenId;
  }
  
  console.log('‚úÖ INFT minted successfully!');
  console.log('  - Token ID:', actualTokenId.toString());
  console.log('  - Transaction Hash:', receipt.hash);
  console.log('  - Block Number:', receipt.blockNumber);
  console.log('  - Gas Used:', receipt.gasUsed.toString());
  
  return {
    tokenId: Number(actualTokenId),
    txHash: receipt.hash,
    gasUsed: receipt.gasUsed.toString()
  };
}

/**
 * Verify the minted token
 */
async function verifyMintedToken(
  deploymentData: DeploymentData,
  tokenId: number,
  expectedOwner: string,
  expectedURI: string,
  expectedHash: string,
  signer: any
): Promise<void> {
  
  console.log('üîç Verifying minted token...');
  
  const INFT = await ethers.getContractFactory('INFT');
  const inftContract = INFT.attach(deploymentData.inft.address).connect(signer);
  
  // Check token owner
  const actualOwner = await inftContract.ownerOf(tokenId);
  if (actualOwner.toLowerCase() !== expectedOwner.toLowerCase()) {
    throw new Error(`Token owner mismatch. Expected: ${expectedOwner}, Actual: ${actualOwner}`);
  }
  
  // Check encrypted URI
  const actualURI = await inftContract.encryptedURI(tokenId);
  if (actualURI !== expectedURI) {
    throw new Error(`Encrypted URI mismatch. Expected: ${expectedURI}, Actual: ${actualURI}`);
  }
  
  // Check metadata hash
  const actualHash = await inftContract.metadataHash(tokenId);
  if (actualHash !== expectedHash) {
    throw new Error(`Metadata hash mismatch. Expected: ${expectedHash}, Actual: ${actualHash}`);
  }
  
  // Check token URI (should return the encrypted URI)
  const tokenURI = await inftContract.tokenURI(tokenId);
  if (tokenURI !== expectedURI) {
    throw new Error(`Token URI mismatch. Expected: ${expectedURI}, Actual: ${tokenURI}`);
  }
  
  console.log('‚úÖ Token verification successful!');
  console.log('  - Owner:', actualOwner);
  console.log('  - Encrypted URI:', actualURI);
  console.log('  - Metadata Hash:', actualHash);
}

/**
 * Update deployment tracking with minted token info
 */
function updateDeploymentTracking(
  deploymentData: DeploymentData,
  mintResult: {tokenId: number, txHash: string, gasUsed: string},
  mintParams: MintParams,
  storageData: StorageData
): void {
  
  console.log('üìù Updating deployment tracking...');
  
  const deploymentPath = path.join(__dirname, '..', 'deployments', 'galileo.json');
  
  // Add minted token information
  const updatedDeployment = {
    ...deploymentData,
    mintedTokens: deploymentData.mintedTokens || [],
  };
  
  // Create token record
  const tokenRecord = {
    tokenId: mintResult.tokenId,
    owner: mintParams.to,
    encryptedURI: mintParams.encryptedURI,
    metadataHash: mintParams.metadataHash,
    storageRootHash: storageData.storageRootHash,
    mintTransaction: {
      hash: mintResult.txHash,
      gasUsed: mintResult.gasUsed,
      timestamp: new Date().toISOString()
    },
    phase1Storage: {
      encryptionKey: storageData.key,
      iv: storageData.iv,
      tag: storageData.tag,
      storageTimestamp: storageData.timestamp
    }
  };
  
  updatedDeployment.mintedTokens.push(tokenRecord);
  
  // Write updated deployment data
  fs.writeFileSync(deploymentPath, JSON.stringify(updatedDeployment, null, 2));
  
  console.log('‚úÖ Deployment tracking updated');
  console.log('  - Added token record for Token ID:', mintResult.tokenId);
}

/**
 * Main execution function
 */
async function main() {
  console.log('üöÄ Starting Phase 4 - Mint INFT');
  console.log('=' .repeat(60));
  
  try {
    // Step 1: Load deployment and storage data
    const deploymentData = loadDeploymentData();
    const storageData = loadStorageData();
    
    // Step 2: Prepare mint parameters
    const [signer] = await ethers.getSigners();
    const mintParams: MintParams = {
      to: signer.address,  // Mint to the deployer address
      encryptedURI: storageData.encryptedURI,
      metadataHash: storageData.metadataHash
    };
    
    // Step 3: Validate parameters and network
    validateMintParams(mintParams);
    const { signer: validatedSigner } = await getNetworkInfo();
    
    // Step 4: Execute the mint
    const mintResult = await mintINFT(deploymentData, mintParams, validatedSigner);
    
    // Step 5: Verify the minted token
    await verifyMintedToken(
      deploymentData,
      mintResult.tokenId,
      mintParams.to,
      mintParams.encryptedURI,
      mintParams.metadataHash,
      validatedSigner
    );
    
    // Step 6: Update deployment tracking
    updateDeploymentTracking(deploymentData, mintResult, mintParams, storageData);
    
    // Step 7: Output final results
    console.log('\nüéØ PHASE 4 RESULTS:');
    console.log('=' .repeat(60));
    console.log('tokenId:', mintResult.tokenId);
    console.log('owner:', mintParams.to);
    console.log('encryptedURI:', mintParams.encryptedURI);
    console.log('metadataHash:', mintParams.metadataHash);
    console.log('transactionHash:', mintResult.txHash);
    console.log('gasUsed:', mintResult.gasUsed);
    console.log('\n‚úÖ Phase 4 completed successfully!');
    console.log('üîó Token is now live on 0G Galileo testnet');
    console.log('üì¶ Encrypted AI agent data is bound to INFT Token ID:', mintResult.tokenId);
    
  } catch (error) {
    console.error('‚ùå Error during minting process:', error);
    process.exit(1);
  }
}

// Allow script to be run with custom parameters
async function mintWithCustomParams(to?: string, encryptedURI?: string, metadataHash?: string) {
  console.log('üöÄ Starting Custom INFT Mint');
  console.log('=' .repeat(60));
  
  try {
    const deploymentData = loadDeploymentData();
    
    let storageData;
    let mintParams: MintParams;
    
    if (encryptedURI && metadataHash) {
      // Use custom parameters
      if (!to) {
        const [signer] = await ethers.getSigners();
        to = signer.address;
      }
      
      mintParams = { to, encryptedURI, metadataHash };
      console.log('üìù Using custom mint parameters');
    } else {
      // Use Phase 1 storage data
      storageData = loadStorageData();
      const [signer] = await ethers.getSigners();
      
      mintParams = {
        to: to || signer.address,
        encryptedURI: encryptedURI || storageData.encryptedURI,
        metadataHash: metadataHash || storageData.metadataHash
      };
      console.log('üìù Using Phase 1 storage data with custom recipient');
    }
    
    validateMintParams(mintParams);
    const { signer } = await getNetworkInfo();
    
    const mintResult = await mintINFT(deploymentData, mintParams, signer);
    
    await verifyMintedToken(
      deploymentData,
      mintResult.tokenId,
      mintParams.to,
      mintParams.encryptedURI,
      mintParams.metadataHash,
      signer
    );
    
    if (storageData) {
      updateDeploymentTracking(deploymentData, mintResult, mintParams, storageData);
    }
    
    console.log('\n‚úÖ Custom mint completed successfully!');
    return mintResult;
    
  } catch (error) {
    console.error('‚ùå Error during custom minting:', error);
    throw error;
  }
}

// Run the main function if this script is executed directly
if (require.main === module) {
  // Check for command line arguments
  const args = process.argv.slice(2);
  if (args.length > 0) {
    const [to, encryptedURI, metadataHash] = args;
    mintWithCustomParams(to, encryptedURI, metadataHash).catch(console.error);
  } else {
    main().catch(console.error);
  }
}

export { main, mintWithCustomParams, loadDeploymentData, loadStorageData };
